\begin{frame}[containsverbatim]{The Reduce function}
  \begin{quote}
    ‘Reduce’ uses a binary function to successively combine the
    elements of a given vector 
  \end{quote}
  
  $\rightsquigarrow$  can   be  use  to  post-process your  list  of
  simulations obtained via \texttt{mclapply}

\begin{block}{Example}
 Work in progress with Avner for "jacknifing" a lasso solution path
\end{block}

<<Reduce.loadt>>=
rm(list=ls())
library(lars)
library(glmnet)
## the diabetes data set (part of the lars package)
data(diabetes)
y <- diabetes$y
x <- diabetes$x
n <- length(y)
@   
\end{frame}

\begin{frame}[containsverbatim]{The Reduce function II}

A single lasso fit 
<<Reduce.pre>>=
## recover a grid of lambda on the complete data set
lasso <- glmnet(x,y)
@ 

\begin{center}
  \begin{minipage}{.6\linewidth}
<<Reduce.plot.lasso, echo=FALSE>>=
plot(lasso)
@   
  \end{minipage}
\end{center}

\end{frame}

\begin{frame}[containsverbatim]{The Reduce function III}

Jacknifing the path
<<Reduce.sim>>=
library(parallel)
## compute the regularization paths for all subsets, 
## removing one individual at once
paths <- mclapply(1:n, function(i) {
    glmnet(x[-i, ], y[-i], lambda = lasso$lambda)$beta
}, mc.cores=4)
@ 

Computing the envelop around the average regularization path with Reduce
<<Reduce.do>>=
mean.path <- Reduce("+", paths)/n
sdev.path <- sqrt(Reduce("+", lapply(paths, function(path) path**2))/n - 
                  mean.path**2)
@ 
\end{frame}

\begin{frame}[containsverbatim]{The Reduce function IV}

<<Reduce.plot, echo=FALSE>>=
library(ggplot2)
library(reshape2)
mean.path <- t(as.matrix(mean.path)); rownames(mean.path) <- lasso$lambda
sdev.path <- t(as.matrix(sdev.path)); rownames(sdev.path) <- lasso$lambda
dplot <- cbind(melt(mean.path), melt(sdev.path)[, 3])
colnames(dplot) <- c("lambda","predictor","mean","sdev")
ggobj <- ggplot(dplot, aes(x=lambda, y=mean, group=predictor, color=predictor)) + geom_smooth(aes(ymin=mean-sdev,ymax=mean+sdev))
print(ggobj + coord_trans(x="log10"))
@ 

\end{frame}

